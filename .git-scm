#!/usr/bin/env bash

# Oh My Zsh Git plugin aliases: https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/git

set +e # Turn off the exit-on-error option

git_default_branch () { # Returns branch checked out when originally cloned ( https://joshtronic.com/2020/08/09/how-to-get-the-default-git-branch )
  (git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@') 2>/dev/null
}

git_merge_default () { # merges from the branch which was checked out on clone
  local defaultBranch=$(git_default_branch)
  echo "Merging from default branch '$defaultBranch'"
  git pull origin $defaultBranch:$defaultBranch
  git pull
  git merge $defaultBranch --no-edit
}

git_pristine () { # Reset to fresh checkout but stash all non-tracked files
  git stash --include-untracked --all
  git reset --hard
  git clean -dfx
}

git_remove_submodule () {
  if [ -z "$1" ]; then
    echo "Please provide the name of the submodule, e.g. remove_submodule common"
    exit 1;
  else
    git submodule deinit $1
    git rm $1
    git commit -m "Removed submodule: $1"
    rm -rf .git/modules/$1
  fi
}

get_ticket_from_branch () { # Returns "PROJ-123" in branch "anything/PROJ-123-some-feature". "PROJ-123" in branch "proj-123-some-feature".
  TICKET=$(git rev-parse --abbrev-ref HEAD | grep -Eo '^(\w+/)?(\w+[-_])?[0-9]+' | grep -Eo '(\w+[-])?[0-9]+' | tr "[:lower:]" "[:upper:]")
  echo "$TICKET"
}

git_commit_ticket () {
  local branch_ticket_id=$(get_ticket_from_branch)
  local commit_message=${1}

  if [ -z "$commit_message" ]; then
    echo 'Commit message missing. Try the following format:'
    echo 'gct "My commit message"'
    return
  else
    echo "Commit message: '$commit_message'"
    if [ -z "$branch_ticket_id" ]; then
      read "REPLY?No ticket id found in branch. Do you want to continue? (y/n): "
      if [[ $REPLY != [Yy]* ]]; then
        echo "Exiting the script."
        exit 0
      fi
    else
      echo "Ticket id: $branch_ticket_id"
      commit_message="[$branch_ticket_id] $commit_message"
    fi
    echo "Full commit message: '$commit_message'"
    git commit -m $commit_message
  fi
}

git_repo() { # Opens the current repo in the browser
    # Get the remote URL from git config
    local remote_url=$(git config --get remote.origin.url)
    
    # Check if we got a URL
    if [ -z "$remote_url" ]; then
        echo "Error: Not in a git repository or no remote origin set"
        return 1
    fi

    # Convert various URL formats to HTTPS
    local https_url=""
    
    # GitHub handling
    if [[ "$remote_url" =~ github\.com ]]; then
        # Handle SSH format (git@github.com:user/repo.git)
        if [[ "$remote_url" =~ ^git@github\.com: ]]; then
            https_url="https://github.com/${remote_url#git@github.com:}"
            https_url="${https_url%.git}"
        # Handle HTTPS format
        elif [[ "$remote_url" =~ ^https://github\.com/ ]]; then
            https_url="${remote_url%.git}"
        fi
    
    # Bitbucket handling
    elif [[ "$remote_url" =~ bitbucket\.org ]]; then
        # Handle SSH format (git@bitbucket.org:user/repo.git)
        if [[ "$remote_url" =~ ^git@bitbucket\.org: ]]; then
            https_url="https://bitbucket.org/${remote_url#git@bitbucket.org:}"
            https_url="${https_url%.git}"
        # Handle HTTPS format
        elif [[ "$remote_url" =~ ^https://bitbucket\.org/ ]]; then
            https_url="${remote_url%.git}"
        fi
    fi

    # If we have a valid URL, open it
    if [ -n "$https_url" ]; then
        # Use appropriate command based on OS
        if [[ "$OSTYPE" == "darwin"* ]]; then
            open "$https_url"    # macOS
        elif [[ "$OSTYPE" == "linux"* ]]; then
            xdg-open "$https_url"  # Linux
        elif [[ "$OSTYPE" == "msys"* || "$OSTYPE" == "cygwin"* ]]; then
            start "$https_url"    # Windows
        else
            echo "URL: $https_url"
            echo "Unsupported OS, please open the URL manually"
            return 1
        fi
    else
        echo "Error: Only GitHub and Bitbucket repositories are supported"
        return 1
    fi
}

git_commit_all_and_push() {
    local commit_message=${1}
    if [ -z "$commit_message" ]; then
        echo 'Commit message missing. Try the following format:'
        echo 'gcap "My commit message"'
        return
    else
        echo "Committing and pushing all changes with message: '$commit_message'"
        git commit --all --message "$commit_message"
        git push
    fi
}

git_commit_all_and_push_no_verify() {
    local commit_message=${1}
    if [ -z "$commit_message" ]; then
        echo 'Commit message missing. Try the following format:'
        echo 'gcapanv "My commit message"'
        return
    else
        echo "Adding, committing and pushing all changes with message: '$commit_message'"
        git commit --all --no-verify --message "$commit_message"
        git push
    fi
}

# Branches
alias gco='git checkout'                                                    # (g)it (c)heck(o)ut
alias gcb='git checkout -b'                                                 # (g)it (c)heck(o)ut (b)ranch

# Commits
alias gc='git commit -m'                                                    # (g)it (c)ommit
alias gcnv='git commit --no-verify -m'                                      # (g)it (c)ommit (n)o (v)erify
alias gca='git commit --all -m'                                             # (g)it (c)ommit (a)ll
alias gcanv='git commit --all --no-verify -m'                               # (g)it (c)ommit (a)ll (n)o (v)erify
alias gcundo='git reset --soft HEAD^'                                       # (g)it (c)ommit (undo)

# Pull
alias gl='git pull'                                                         # (g)it (p)ull

# Push
alias gp='git push'                                                         # (g)it (p)ush
alias gpnv='git push --no-verify'                                           # (g)it (p)ush (n)o (v)erify

# Commit & Push
alias gcap='git_commit_all_and_push'
alias gcapanv='git_commit_all_and_push_no_verify'

# Default branch
alias gcdf='git checkout $(git_default_branch) && git pull &'               # (g)it (s)witch (d)e(f)ault
alias gmdf='git_merge_default'                                              # (g)it (m)erge (d)e(f)ault
alias grbdf='git rebase $(git_default_branch)'                              # (g)it (r)ebase (b)ranch (d)e(f)ault
alias gfdf='git fetch origin $(git_default_branch):$(git_default_branch)'   # (g)it (f)etch (d)e(f)ault

# Miscellaneous
# alias gpristine='git reset --hard && git clean --force -dfx'              # Stash first           
alias gssu='git stash save --include-untracked'                             # (g)it (st)ash (s)ave including (u)ntracked - alternative to OhMyZsh git plugin which pushes rather than saves
alias gct='git_commit_ticket'                                               # (g)it (c)ommit (t)icket
alias repo='git_repo'                                                       # open the repo in browser
alias cb='git rev-parse --abbrev-ref HEAD | tr -d "\n" | pbcopy'            # {c}opy (b)ranch
alias gpristine=git_pristine                                                # {g}it pristine (OhMyZsh equivalent)